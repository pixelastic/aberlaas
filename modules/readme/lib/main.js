import { consoleWarn, exists, firostError, read, write } from 'firost';
import { _, pMap } from 'golgoth';
import dedent from 'dedent';
import frontMatter from 'front-matter';
import { hostGitPath } from 'aberlaas-helper';

/**
 * Warns the user if they are using the deprecated README template location.
 * Checks for the old template path and displays warning messages if found.
 * @returns {Promise<void>} A promise that resolves when the check is complete
 */
async function warnIfDeprecatedTemplate() {
  const oldTemplate = hostGitPath('.github/README.template.md');
  if (await exists(oldTemplate)) {
    consoleWarn('aberlaas: Readme template location has changed.');
    consoleWarn(
      'Please move ./.github/README.template.md to ./.README.template.md',
    );
  }
}

/**
 * Extracts and processes template data including inputs, outputs, and body content
 * @param {string} templatePath - Path to the template file to process
 * @returns {object} Object containing processed inputs array, outputs array, and template body content
 */
async function getTemplateData(templatePath) {
  const rawContent = await read(templatePath);
  const parsed = frontMatter(rawContent);

  // Template content
  const body = parsed.body;

  // Inputs
  const fileRegexp = /{file:(?<filepath>[^}]+)}/gm;
  const matches = Array.from(body.matchAll(fileRegexp));
  const inputs = _.chain(matches)
    .map((match) => match.groups.filepath)
    .map((filepath) => {
      return {
        match: filepath,
        filepath: hostGitPath(filepath),
      };
    })
    .value();

  await pMap(inputs, async (input) => {
    const { match, filepath } = input;
    if (await exists(filepath)) {
      return;
    }
    throw firostError(
      'ABERLAAS_README_MISSING_INPUT',
      `Unable to find file to include for {file:${match}} in ${templatePath}`,
    );
  });

  // We parse the template to get all the included files
  const outputs = _.map(parsed.attributes.outputs, hostGitPath);

  return {
    inputs,
    outputs,
    body,
  };
}

export default {
  /**
   * Update the various README.md files based on the template
   * @param {object} cliArgs CLI Argument object, as created by minimist
   * @param {string} cliArgs.template Path to the template (default to .README.template.md)
   * @param {Array} cliArgs._ List of files that changed (passed by lint-staged)
   */
  async run(cliArgs) {
    await warnIfDeprecatedTemplate();

    // Stop if no template defined
    const templatePath = hostGitPath('.README.template.md');
    if (!(await exists(templatePath))) {
      throw firostError(
        'ABERLAAS_README_MISSING_TEMPLATE',
        'README template not found at .README.template.md',
      );
    }

    // Get the inputs, outputs, and template code
    const { inputs, outputs, body } = await getTemplateData(templatePath);
    if (_.isEmpty(outputs)) {
      throw firostError(
        'ABERLAAS_README_MISSING_OUTPUTS',
        'File .README.template.md is missing an outputs: key in its frontmatter',
      );
    }

    // Args are passed, so we need to stop if none require the README to be
    // regenerated
    const cliFiles = cliArgs._;
    if (!_.isEmpty(cliFiles)) {
      const filesTriggeringChange = [
        ...outputs,
        ..._.map(inputs, 'filepath'),
        templatePath,
      ];
      const changedFiles = _.map(cliFiles, (filepath) => hostGitPath(filepath));

      // Stop if no relevant files
      const intersection = _.intersection(changedFiles, filesTriggeringChange);
      if (_.isEmpty(intersection)) {
        return;
      }
    }

    // Convert the template into the final content
    let content = dedent`
    <!--
      This file was automatically generated by 'aberlaas readme' from ${templatePath}
      DO NOT EDIT MANUALLY
    -->
    ${body}
    `;
    await pMap(inputs, async (input) => {
      const { match, filepath } = input;
      const includedContent = await read(filepath);
      content = _.replace(content, `{file:${match}}`, includedContent);
    });

    // Update all outputs
    await pMap(outputs, async (outputPath) => {
      await write(content, outputPath);
    });
  },
};
